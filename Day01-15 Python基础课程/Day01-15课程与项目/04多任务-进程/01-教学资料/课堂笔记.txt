线程知识回顾
	1 多任务
		并行
		并发
	2 父线程与子线程
		一个进程中默认只有一个线程 --- 主线程

	3 创建子线程的两种方法
		使用Thread类 实例对象 
			class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)
			常用参数
				target指定子线程运行的函数名
			    args执行子线程的函数代码在运行时 的参数
		thd = threading.Thread()

		
		使用Thread子类 实例对象
			实现其中的run()方法

		
		thd.start()方法 只是启动子线程的创建和执行  

	4 主线程等待子线程退出

		默认情况下父线程会等待所有子线程退出
		如果需要在子线程执行完成后 还需要执行一些代码(比如检测子线程+10000次之后的运算结果) 需要在主线程中使用 Thread实例对象.join()

	5 同一个进程内部的多个线程 共享全局变量

	6 多线程同步--秩序
	
		互斥锁保证在任何一个时间点只有 一个 任务可以获取并占有 锁资源 
		   
		创建锁资源 mutex = threading.Lock()

		获取锁资源 mutex.acquire()

			在默认情况下 如果锁已经被其他任务锁定 那么 本次获取将会阻塞该任务的执行

		释放锁资源 mutex.release()
      
    7 互斥锁的优缺点
    	优点 
    		保证多任务修改共享数据时能够同步 使运算结果正确
    	缺点
    		丧失多任务优势 
    		容易造成死锁问题

    8 死锁问题

    	任务在获取锁时造成 一直在等待(死等) 锁资源 而不能成功获取

    	原因:
    		没有正确释放      -- 
    			用户规范 用完一定要关 
    			权宜之计就是在获取锁的时候 使用非阻塞 或者 阻塞+超时等待 方式获取锁
    		多种锁资源分配不当 -- 银行家算法可以解决该问题


    9 acquire()方法功能说明

		acquire(blocking=True, timeout=-1)
		函数作用 申请锁资源
		参数含义 blocking参数表示是否阻塞 True表示阻塞 False表示非阻塞(不阻塞等待)
		        timeoute参数表示阻塞等待的最长时间 超时则放弃等待
		        -1表示死等
		        如果是一个正数 代表等待这么秒

		返回值 表示是否成功获取到锁资源 True表示成功获取  False表示获取失败


今天
	
	1. 程序 与 进程
		程序是一个静态概念  是存在于外存上的一段文件数据
		进程是一个动态概念  数据 + 系统资源的统称

	2. 进程的  经典三个状态

	         <---CPU分配的时间片用完---
		就绪  -----CPU分配时间片执行--> 运行   -----等待条件---> 阻塞
		    <--------等待的条件已经满足--------------------------|

		就绪   除CPU资源之外的所有资源已经分配  

		运行   CPU执行该进程
			  在时间片用完的情况会切换到就绪态

		等待   在运行的代码中有需要等待的条件(数据input()、时间sleep(1)) 阻塞等待
              如果条件满足 切换到就绪态

	3. 创建进程
		# 创建子进程执行的计划
		pro = multiprocessing.Process(target=函数名,args=(参数列表元组))
		# 启动子进程的创建和执行
		pro.start()
	4. 主进程阻塞等待子进程退出
		pro.join(超时时间) 表示主进程 最多等子进程多少s 
		pro.is_alive()    判断子进程是否存活
		pro.terminate()   直接终结 (信号-->延时) ---> .join()

		pro.pid 打印出进程的pid 如果进程没有创建则没有pid
		pro.name Porcess-N


	5.  进程间通信 Queue
    	创建队列 
    		q = multiprocessing.Queue() 该函数参数表示队列长度
    	往队列中放入数据  参数是需要放入的数据 如果队列已满 则会阻塞等待 直到队列中有空可以存储数据
    		q.put(data)

    	从队列中取出数据 返回值是取出的数据  如果没有数据 默认会阻塞死等
    		q.get()
